name: CD
on:
  # Run CD after CI succeeds (best practice: quality gate)
  workflow_run:
    workflows: ["CI"]
    types: [completed]
    branches: [master, main]
  # Tags can trigger immediately (typically created after CI passes)
  push:
    tags:
      - 'v*'
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/dm-nkp-gitops-a2a-server
  CATALOG_REPO: dm-nkp-gitops-app-catalog
  CATALOG_OWNER: ${{ github.repository_owner }}
  # Catalog update method: "pr" (recommended, more secure) or "push" (direct commit, faster)
  # Can be overridden via repository variable: CATALOG_UPDATE_METHOD
  CATALOG_UPDATE_METHOD: pr
jobs:
  docker:
    runs-on: ubuntu-latest
    # Only run if CI succeeded (workflow_run) or triggered by tag (push)
    if: github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success'
    permissions:
      contents: read
      packages: write
      id-token: write  # Required for keyless signing
    steps:
      - uses: actions/checkout@v4
        with:
          # workflow_run: checkout the commit that triggered CI; tag push: use the tag
          ref: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.ref }}
      
      # Determine version based on trigger type
      # Docker images can use any tag format, but we'll use semver for consistency
      - id: version
        run: |
          # Detect if triggered by tag or branch (workflow_run or direct push)
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            # Extract version from tag (v1.2.3 -> 1.2.3)
            VERSION="${GITHUB_REF#refs/tags/v}"
            echo "is_release=true" >> $GITHUB_OUTPUT
          else
            # For branch pushes (workflow_run or direct), use semver prerelease format
            # Get actual branch name and SHA from checkout
            ACTUAL_SHA=$(git rev-parse HEAD | cut -c1-7)
            if [ "${{ github.event_name }}" = "workflow_run" ]; then
              # workflow_run: use branch from event context
              BRANCH_NAME="${{ github.event.workflow_run.head_branch }}"
            else
              # Direct push: use ref_name
              BRANCH_NAME="${{ github.ref_name }}"
            fi
            # Sanitize branch name (replace invalid semver chars with hyphens)
            BRANCH_NAME=$(echo "${BRANCH_NAME}" | sed 's/[^a-zA-Z0-9-]/-/g' | tr '[:upper:]' '[:lower:]')
            VERSION="0.0.0-${BRANCH_NAME}-${ACTUAL_SHA}"
            echo "is_release=false" >> $GITHUB_OUTPUT
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Version determined: ${VERSION}"
      
      # Install Cosign for image signing
      # Using v3.10.1 (latest v3.x) which installs Cosign v2.6.1
      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.10.1
      
      # Set up Docker Buildx
      - uses: docker/setup-buildx-action@v3
      
      # Login to GitHub Container Registry
      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      # Determine CI image reference (reuse image built in CI)
      - name: Determine CI image reference
        id: ci-image
        run: |
          # Get the SHA that CI used (from workflow_run or current ref)
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            CI_SHA="${{ github.event.workflow_run.head_sha }}"
          else
            CI_SHA="${{ github.sha }}"
          fi
          SHORT_SHA=$(echo "${CI_SHA}" | cut -c1-7)
          BRANCH_NAME=$(echo "${{ github.ref_name }}" | sed 's/[^a-zA-Z0-9-]/-/g' | tr '[:upper:]' '[:lower:]')
          CI_IMAGE_TAG="${BRANCH_NAME}-${SHORT_SHA}"
          CI_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:ci-${CI_IMAGE_TAG}"
          echo "ci_image=${CI_IMAGE}" >> $GITHUB_OUTPUT
          echo "CI image to reuse: ${CI_IMAGE}"
      
      # Pull CI-built image (reuse instead of rebuilding)
      - name: Pull CI-built image
        id: pull-ci-image
        run: |
          echo "Pulling CI-built image: ${{ steps.ci-image.outputs.ci_image }}"
          if docker pull "${{ steps.ci-image.outputs.ci_image }}" 2>&1; then
            echo "âœ… Successfully pulled CI image"
            # Get image digest
            DIGEST=$(docker inspect "${{ steps.ci-image.outputs.ci_image }}" --format='{{index .RepoDigests 0}}' | cut -d'@' -f2)
            echo "digest=${DIGEST}" >> $GITHUB_OUTPUT
            echo "Image digest: ${DIGEST}"
          else
            echo "âš ï¸ Could not pull CI image, will build new image"
            echo "digest=" >> $GITHUB_OUTPUT
          fi
      
      # Determine additional tags
      - name: Set additional tags
        id: additional-tags
        run: |
          if [ "${{ steps.version.outputs.is_release }}" = "true" ]; then
            echo "tag=latest" >> $GITHUB_OUTPUT
          else
            echo "tag=${{ github.ref_name }}-latest" >> $GITHUB_OUTPUT
          fi
      
      # Tag and push CI image as production image (reuse instead of rebuilding)
      - name: Tag and push production image (reuse CI image)
        id: build
        if: steps.pull-ci-image.outputs.digest != ''
        run: |
          CI_IMAGE="${{ steps.ci-image.outputs.ci_image }}"
          PROD_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }}"
          PROD_TAG="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.additional-tags.outputs.tag }}"
          
          echo "Reusing CI image: ${CI_IMAGE}"
          echo "Tagging as production: ${PROD_IMAGE}"
          
          # Tag the CI image with production tags
          docker tag "${CI_IMAGE}" "${PROD_IMAGE}"
          docker tag "${CI_IMAGE}" "${PROD_TAG}"
          
          # Push production tags
          docker push "${PROD_IMAGE}"
          docker push "${PROD_TAG}"
          
          # Get digest for signing
          DIGEST=$(docker inspect "${PROD_IMAGE}" --format='{{index .RepoDigests 0}}' | cut -d'@' -f2)
          echo "digest=${DIGEST}" >> $GITHUB_OUTPUT
          echo "âœ… Production image pushed: ${PROD_IMAGE}"
          echo "Digest: ${DIGEST}"
      
      # Fallback: Build new image if CI image not available
      - name: Build and push Docker image (fallback if CI image not available)
        id: build-fallback
        if: steps.pull-ci-image.outputs.digest == ''
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.additional-tags.outputs.tag }}
          platforms: linux/amd64,linux/arm64
          build-args: |
            VERSION=${{ steps.version.outputs.version }}
            GIT_COMMIT=${{ github.sha }}
            BUILD_TIME=${{ github.event.head_commit.timestamp }}
          file: ./Dockerfile
          cache-from: type=gha
          cache-to: type=gha,mode=max
      
      # Set digest output (from either reuse or fallback build)
      - name: Set final image digest
        id: final-digest
        run: |
          # Get digest from either reused CI image or fallback build
          if [ -n "${{ steps.build.outputs.digest }}" ]; then
            echo "digest=${{ steps.build.outputs.digest }}" >> $GITHUB_OUTPUT
          elif [ -n "${{ steps.build-fallback.outputs.digest }}" ]; then
            echo "digest=${{ steps.build-fallback.outputs.digest }}" >> $GITHUB_OUTPUT
          else
            # Fallback: Get digest from image tag
            IMAGE_TAG="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }}"
            DIGEST=$(docker inspect "${IMAGE_TAG}" --format='{{index .RepoDigests 0}}' 2>/dev/null | cut -d'@' -f2 || echo "")
            echo "digest=${DIGEST}" >> $GITHUB_OUTPUT
          fi
          echo "Final digest: ${{ steps.final-digest.outputs.digest }}"
      
      # Verify build output and OCI registry
      - name: Verify Docker image in OCI registry
        run: |
          echo "Final image digest: ${{ steps.final-digest.outputs.digest }}"
          if [ -z "${{ steps.final-digest.outputs.digest }}" ]; then
            echo "âŒ Error: Image digest is empty - build may have failed"
            exit 1
          else
            echo "âœ… Image digest available: ${{ steps.final-digest.outputs.digest }}"
          fi
          
          # Verify image is accessible in OCI registry
          IMAGE_TAG="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }}"
          echo "Verifying Docker image is in OCI registry: ${IMAGE_TAG}"
          if docker manifest inspect "${IMAGE_TAG}" >/dev/null 2>&1; then
            echo "âœ… Docker image verified in OCI registry: ${IMAGE_TAG}"
          else
            echo "âš ï¸ Warning: Could not verify image immediately (may need a moment to propagate)"
            echo "Image should be available at: ${IMAGE_TAG}"
          fi
      
      # Scan production container image for vulnerabilities (OS + dependencies)
      # This scans the actual production image that gets deployed, including:
      # - Base image OS packages (alpine, debian, ubuntu, etc.)
      # - Application dependencies in container
      # - All container layers
      - name: Scan production container image with Trivy
        if: steps.final-digest.outputs.digest != ''
        continue-on-error: true
        env:
          IMAGE_TAG: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }}
        run: |
          if [ -z "${{ steps.final-digest.outputs.digest }}" ]; then
            echo "âš ï¸ No digest available, skipping container scan"
            exit 0
          fi
          
          echo "ðŸ” Scanning production container image: ${IMAGE_TAG}"
          echo ""
          echo "This scan covers:"
          echo "  âœ“ Base image OS packages (alpine, debian, ubuntu, etc.)"
          echo "  âœ“ Application dependencies in container"
          echo "  âœ“ All container layers"
          echo "  âœ“ Runtime vulnerabilities"
          echo ""
          
          # Install Trivy
          echo "Installing Trivy..."
          sudo apt-get update -qq
          sudo apt-get install -y wget apt-transport-https gnupg lsb-release >/dev/null 2>&1
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add - >/dev/null 2>&1
          echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list >/dev/null
          sudo apt-get update -qq
          sudo apt-get install -y trivy >/dev/null 2>&1
          
          # Wait for image to be fully available in registry
          echo "Waiting for image to be available in registry..."
          sleep 5
          
          # Scan image and output results (table format for logs)
          echo "Running Trivy vulnerability scan..."
          trivy image --exit-code 0 --severity CRITICAL,HIGH,MEDIUM \
            --format table \
            --output trivy-production-scan.txt \
            "${IMAGE_TAG}" || {
            echo "âš ï¸ Trivy found vulnerabilities (see report above)"
          }
          
          # Display summary in logs
          if [ -f trivy-production-scan.txt ]; then
            echo ""
            echo "=== Production Container Vulnerability Scan Results ==="
            cat trivy-production-scan.txt
            echo ""
            echo "ðŸ’¡ Tip: Review critical/high vulnerabilities and update base image if needed"
          fi
          
          # Generate SARIF for GitHub Security tab
          echo "Generating SARIF report for GitHub Security tab..."
          trivy image --format sarif \
            --output trivy-production-scan.sarif \
            --severity CRITICAL,HIGH,MEDIUM \
            "${IMAGE_TAG}" || {
            echo "âš ï¸ SARIF generation failed (non-blocking)"
            exit 0
          }
      
      - name: Upload production container scan results to GitHub Security tab
        if: steps.final-digest.outputs.digest != '' && hashFiles('trivy-production-scan.sarif') != ''
        uses: github/codeql-action/upload-sarif@v4
        permissions:
          security-events: write
        with:
          sarif_file: 'trivy-production-scan.sarif'
          category: 'trivy-production-container'
      
      # Sign the image using keyless signing (OIDC)
      - name: Sign container image
        continue-on-error: true
        env:
          IMAGE_DIGEST: ${{ steps.final-digest.outputs.digest }}
          IMAGE_TAG: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.final-digest.outputs.digest }}
        run: |
          if [ -z "${IMAGE_DIGEST}" ] || [ "${IMAGE_DIGEST}" = "" ]; then
            echo "âš ï¸ Image digest is empty, skipping signing"
            echo "Build step outputs:"
            echo "  digest: ${{ steps.build.outputs.digest }}"
            exit 0
          fi
          
          echo "Signing image: ${IMAGE_TAG}"
          echo "Digest: ${IMAGE_DIGEST}"
          
          # For multi-platform builds, wait longer for manifest to be available
          echo "Waiting for image manifest to be available in registry..."
          sleep 5
          
          # Try to verify image exists before signing
          if ! docker manifest inspect ${IMAGE_TAG} >/dev/null 2>&1; then
            echo "âš ï¸ Image manifest not yet available, waiting..."
            sleep 10
          fi
          
          # Sign with retry and better error handling
          MAX_RETRIES=3
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if cosign sign --yes ${IMAGE_TAG} 2>&1; then
              echo "âœ… Image signed successfully"
              exit 0
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "âš ï¸ Signing attempt $RETRY_COUNT failed, retrying in 5 seconds..."
                sleep 5
              else
                echo "âŒ Signing failed after $MAX_RETRIES attempts"
                echo "This is non-blocking - image is still available without signature"
                echo "You can sign it manually later if needed"
                exit 0
              fi
            fi
          done
      
      # Verify the signature
      - name: Verify image signature
        if: steps.final-digest.outputs.digest != ''
        continue-on-error: true
        env:
          IMAGE_TAG: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.final-digest.outputs.digest }}
        run: |
          if [ -z "${{ steps.final-digest.outputs.digest }}" ]; then
            echo "âš ï¸ No digest available, skipping verification"
            exit 0
          fi
          
          echo "Verifying signature for: ${IMAGE_TAG}"
          if cosign verify ${IMAGE_TAG} \
            --certificate-identity-regexp ".*" \
            --certificate-oidc-issuer "https://token.actions.githubusercontent.com"; then
            echo "âœ… Signature verified successfully"
          else
            echo "âš ï¸ Signature verification failed (non-blocking)"
            exit 0
          fi
  
  helm:
    runs-on: ubuntu-latest
    needs: docker
    permissions:
      contents: read
      packages: write
      id-token: write  # Required for signing Helm charts
    outputs:
      chart_version: ${{ steps.job-outputs.outputs.chart_version }}
      is_release: ${{ steps.job-outputs.outputs.is_release }}
    steps:
      - uses: actions/checkout@v4
        with:
          # workflow_run: checkout the commit that triggered CI; tag push: use the tag
          ref: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.ref }}
      
      # Determine version based on trigger type
      # Helm requires semver format, so branch pushes use prerelease format
      - id: version
        run: |
          # Detect if triggered by tag or branch (workflow_run or direct push)
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            # Extract version from tag (v1.2.3 -> 1.2.3)
            VERSION="${GITHUB_REF#refs/tags/v}"
            echo "is_release=true" >> $GITHUB_OUTPUT
          else
            # For branch pushes (workflow_run or direct), use semver prerelease format
            # Get actual branch name and SHA from checkout
            ACTUAL_SHA=$(git rev-parse HEAD | cut -c1-7)
            if [ "${{ github.event_name }}" = "workflow_run" ]; then
              # workflow_run: use branch from event context
              BRANCH_NAME="${{ github.event.workflow_run.head_branch }}"
            else
              # Direct push: use ref_name
              BRANCH_NAME="${{ github.ref_name }}"
            fi
            # Sanitize branch name (replace invalid semver chars with hyphens)
            BRANCH_NAME=$(echo "${BRANCH_NAME}" | sed 's/[^a-zA-Z0-9-]/-/g' | tr '[:upper:]' '[:lower:]')
            VERSION="0.0.0-${BRANCH_NAME}-${ACTUAL_SHA}"
            echo "is_release=false" >> $GITHUB_OUTPUT
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Version determined: ${VERSION}"
      
      # Install Cosign for chart signing
      # Using v3.10.1 (latest v3.x) which installs Cosign v2.6.1
      # v4.x is for Cosign v3.x, but v2.x is more stable for now
      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.10.1
      
      # Install Helm
      - uses: azure/setup-helm@v4
      
      # Update Chart.yaml with version
      - name: Update Chart version
        run: |
          if [ -f "chart/dm-nkp-gitops-a2a-server/Chart.yaml" ]; then
            sed -i "s/^version:.*/version: ${{ steps.version.outputs.version }}/" chart/dm-nkp-gitops-a2a-server/Chart.yaml
            sed -i "s/^appVersion:.*/appVersion: \"${{ steps.version.outputs.version }}\"/" chart/dm-nkp-gitops-a2a-server/Chart.yaml
            echo "âœ… Chart.yaml updated to version ${{ steps.version.outputs.version }}"
          else
            echo "âŒ Chart.yaml not found at chart/dm-nkp-gitops-a2a-server/Chart.yaml"
            exit 1
          fi
      
      # Package Helm chart
      - name: Package Helm chart
        run: |
          mkdir -p .helm-packages
          helm package chart/dm-nkp-gitops-a2a-server -d .helm-packages
      
      # Login to OCI registry
      - name: Login to OCI registry
        run: |
          echo "Logging into Helm OCI registry: ${{ env.REGISTRY }}"
          echo "${{ secrets.GITHUB_TOKEN }}" | helm registry login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin || {
            echo "âŒ Failed to login to Helm registry"
            echo "Registry: ${{ env.REGISTRY }}"
            echo "User: ${{ github.actor }}"
            echo "Check that GITHUB_TOKEN has packages:write permission"
            exit 1
          }
          echo "âœ… Successfully logged into Helm OCI registry"
      
      # Push Helm chart to OCI registry
      - name: Push Helm chart
        run: |
          CHART_FILE=".helm-packages/dm-nkp-gitops-a2a-server-${{ steps.version.outputs.version }}.tgz"
          CHART_OCI_URL="oci://${{ env.REGISTRY }}/${{ github.repository_owner }}/charts/dm-nkp-gitops-a2a-server"
          
          if [ ! -f "${CHART_FILE}" ]; then
            echo "âŒ Chart file not found: ${CHART_FILE}"
            exit 1
          fi
          
          echo "Pushing Helm chart to OCI registry:"
          echo "  Chart: ${CHART_FILE}"
          echo "  OCI URL: ${CHART_OCI_URL}"
          echo "  Version: ${{ steps.version.outputs.version }}"
          
          helm push "${CHART_FILE}" "${CHART_OCI_URL}" || {
            echo "âŒ Failed to push Helm chart to OCI registry"
            exit 1
          }
          
          echo "âœ… Helm chart pushed successfully to OCI registry"
          echo "Chart available at: ${CHART_OCI_URL}:${{ steps.version.outputs.version }}"
      
      # Verify Helm chart in OCI registry
      - name: Verify Helm chart in OCI registry
        run: |
          CHART_OCI_URL="oci://${{ env.REGISTRY }}/${{ github.repository_owner }}/charts/dm-nkp-gitops-a2a-server"
          CHART_VERSION="${{ steps.version.outputs.version }}"
          
          echo "Verifying Helm chart is in OCI registry:"
          echo "  Chart: ${CHART_OCI_URL}"
          echo "  Version: ${CHART_VERSION}"
          
          # Try to show chart info from OCI registry
          if helm show chart "${CHART_OCI_URL}" --version "${CHART_VERSION}" >/dev/null 2>&1; then
            echo "âœ… Helm chart verified in OCI registry"
            helm show chart "${CHART_OCI_URL}" --version "${CHART_VERSION}" | head -10
          else
            echo "âš ï¸ Warning: Could not verify chart immediately (may need a moment to propagate)"
            echo "Chart should be available at: ${CHART_OCI_URL}:${CHART_VERSION}"
          fi
      
      # Sign Helm chart
      - name: Sign Helm chart
        env:
          CHART_PATH: .helm-packages/dm-nkp-gitops-a2a-server-${{ steps.version.outputs.version }}.tgz
          # Initialize TUF root to avoid "invalid key" errors
          SIGSTORE_TUF_ROOT: "https://tuf-repo-cdn.sigstore.dev"
        run: |
          if [ ! -f "${CHART_PATH}" ]; then
            echo "âŒ Chart file not found: ${CHART_PATH}"
            exit 1
          fi
          
          echo "Signing Helm chart: ${CHART_PATH}"
          
          # Clear any stale TUF cache to force fresh metadata fetch
          echo "Clearing TUF cache to ensure fresh metadata..."
          rm -rf "${HOME}/.sigstore/tuf" 2>/dev/null || true
          rm -rf "${HOME}/.sigstore/root.json" 2>/dev/null || true
          
          # Initialize TUF root metadata first (this helps avoid "invalid key" errors)
          echo "Initializing TUF root metadata..."
          cosign initialize --mirror "${SIGSTORE_TUF_ROOT}" --root "${SIGSTORE_TUF_ROOT}/root.json" || {
            echo "âš ï¸ TUF initialization failed, but continuing with signing attempt..."
          }
          
          # Retry logic for signing with proper error handling
          MAX_RETRIES=3
          RETRY_COUNT=0
          SIGN_SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Signing attempt $((RETRY_COUNT + 1)) of ${MAX_RETRIES}..."
            
            if cosign sign-blob --yes ${CHART_PATH} \
              --output-signature ${CHART_PATH}.sig \
              --output-certificate ${CHART_PATH}.pem 2>&1; then
              echo "âœ… Chart signed successfully"
              SIGN_SUCCESS=true
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "âš ï¸ Signing attempt ${RETRY_COUNT} failed"
                echo "Common causes: TUF metadata update issues, network problems"
                echo "Retrying in 10 seconds after clearing TUF cache..."
                sleep 10
                # Clear TUF cache again before retry
                rm -rf "${HOME}/.sigstore/tuf" 2>/dev/null || true
                # Re-initialize TUF
                cosign initialize --mirror "${SIGSTORE_TUF_ROOT}" --root "${SIGSTORE_TUF_ROOT}/root.json" 2>/dev/null || true
              fi
            fi
          done
          
          if [ "${SIGN_SUCCESS}" != "true" ]; then
            echo "âŒ Failed to sign chart after ${MAX_RETRIES} attempts"
            echo ""
            echo "Troubleshooting steps:"
            echo "1. Check Sigstore TUF mirror status: ${SIGSTORE_TUF_ROOT}"
            echo "2. Verify network connectivity"
            echo "3. Check Cosign version: $(cosign version)"
            echo "4. Review TUF cache: ls -la ${HOME}/.sigstore/"
            exit 1
          fi
      
      # Upload signed chart artifacts
      - name: Upload signed chart artifacts
        uses: actions/upload-artifact@v4
        with:
          name: helm-chart-signed
          path: |
            .helm-packages/dm-nkp-gitops-a2a-server-${{ steps.version.outputs.version }}.tgz
            .helm-packages/dm-nkp-gitops-a2a-server-${{ steps.version.outputs.version }}.tgz.sig
            .helm-packages/dm-nkp-gitops-a2a-server-${{ steps.version.outputs.version }}.tgz.pem
          retention-days: 90
      
      # Set job outputs for catalog update
      - name: Set job outputs
        id: job-outputs
        run: |
          echo "chart_version=${{ steps.version.outputs.version }}" >> $GITHUB_OUTPUT
          echo "is_release=${{ steps.version.outputs.is_release }}" >> $GITHUB_OUTPUT

  update-catalog:
    runs-on: ubuntu-latest
    needs: helm
    permissions:
      contents: write  # Required to push to catalog repo
      pull-requests: write  # Required to create PRs
    if: always() && needs.helm.result == 'success'
    # Continue even if catalog update fails (non-blocking)
    continue-on-error: true
    steps:
      - name: Determine authentication token
        id: auth
        run: |
          # Use PAT if available (for cross-org), otherwise use GITHUB_TOKEN
          if [ -n "${{ secrets.CATALOG_REPO_TOKEN }}" ]; then
            echo "token=${{ secrets.CATALOG_REPO_TOKEN }}" >> $GITHUB_OUTPUT
            echo "auth_method=pat" >> $GITHUB_OUTPUT
            echo "âœ… Using PAT for authentication (cross-org support enabled)"
          else
            echo "token=${{ secrets.GITHUB_TOKEN }}" >> $GITHUB_OUTPUT
            echo "auth_method=github_token" >> $GITHUB_OUTPUT
            echo "â„¹ï¸ Using GITHUB_TOKEN (same-org only)"
            echo "ðŸ’¡ For cross-org access, add CATALOG_REPO_TOKEN secret"
          fi
      
      - name: Checkout catalog repository
        uses: actions/checkout@v4
        with:
          repository: ${{ env.CATALOG_OWNER }}/${{ env.CATALOG_REPO }}
          token: ${{ steps.auth.outputs.token }}
          path: catalog-repo
          # For PR method, fetch all branches
          fetch-depth: 0
        continue-on-error: true
      
      - name: Verify catalog repository access
        id: verify-access
        continue-on-error: true
        run: |
          if [ ! -d "catalog-repo" ] || [ ! -f "catalog-repo/.git/config" ]; then
            echo "access_ok=false" >> $GITHUB_OUTPUT
            echo "âŒ Failed to checkout catalog repository"
            echo ""
            echo "**Possible causes:**"
            echo "1. Catalog repo doesn't exist: ${{ env.CATALOG_OWNER }}/${{ env.CATALOG_REPO }}"
            echo "2. Cross-org access needed - Add CATALOG_REPO_TOKEN secret"
            echo "3. Repository is private and token lacks access"
            echo ""
            echo "Workflow will continue but catalog won't be updated."
          else
            echo "access_ok=true" >> $GITHUB_OUTPUT
            echo "âœ… Successfully checked out catalog repository"
          fi
      
      - name: Configure Git
        if: steps.verify-access.outputs.access_ok == 'true'
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
      
      - name: Determine catalog update strategy
        id: catalog-strategy
        run: |
          # Check if catalog repo was successfully checked out
          if [ "${{ steps.verify-access.outputs.access_ok }}" != "true" ] || [ ! -d "catalog-repo" ]; then
            echo "strategy=skip" >> $GITHUB_OUTPUT
            echo "file_path=" >> $GITHUB_OUTPUT
            echo "âš ï¸ Catalog repo not available, skipping update"
            exit 0
          fi
          
          # Check if catalog uses HelmRelease, OCIRepository, or catalog manifest
          if [ -f "catalog-repo/apps/dm-nkp-gitops-a2a-server/helmrelease.yaml" ]; then
            echo "strategy=helmrelease" >> $GITHUB_OUTPUT
            echo "file_path=apps/dm-nkp-gitops-a2a-server/helmrelease.yaml" >> $GITHUB_OUTPUT
          elif [ -f "catalog-repo/apps/dm-nkp-gitops-a2a-server/ocirepository.yaml" ]; then
            echo "strategy=ocirepository" >> $GITHUB_OUTPUT
            echo "file_path=apps/dm-nkp-gitops-a2a-server/ocirepository.yaml" >> $GITHUB_OUTPUT
          elif [ -f "catalog-repo/catalog.yaml" ]; then
            echo "strategy=catalog-manifest" >> $GITHUB_OUTPUT
            echo "file_path=catalog.yaml" >> $GITHUB_OUTPUT
          elif [ -f "catalog-repo/apps.yaml" ]; then
            echo "strategy=apps-manifest" >> $GITHUB_OUTPUT
            echo "file_path=apps.yaml" >> $GITHUB_OUTPUT
          else
            echo "strategy=auto-create" >> $GITHUB_OUTPUT
            echo "file_path=apps/dm-nkp-gitops-a2a-server/helmrelease.yaml" >> $GITHUB_OUTPUT
          fi
      
      - name: Update HelmRelease
        if: steps.catalog-strategy.outputs.strategy == 'helmrelease'
        working-directory: catalog-repo
        env:
          CHART_URL: oci://${{ env.REGISTRY }}/${{ github.repository_owner }}/charts/dm-nkp-gitops-a2a-server
          CHART_VERSION: ${{ needs.helm.outputs.chart_version }}
          FILE_PATH: ${{ steps.catalog-strategy.outputs.file_path }}
        run: |
          echo "Updating HelmRelease at ${FILE_PATH}"
          # Update chart version in HelmRelease
          if command -v yq &> /dev/null; then
            yq eval ".spec.chart.spec.version = \"${CHART_VERSION}\"" -i "${FILE_PATH}"
            yq eval ".spec.chart.spec.sourceRef.name = \"dm-nkp-gitops-a2a-server-chart\"" -i "${FILE_PATH}" 2>/dev/null || true
          else
            # Fallback to sed if yq is not available
            sed -i "s|version:.*|version: ${CHART_VERSION}|g" "${FILE_PATH}"
            sed -i "s|chart:.*dm-nkp-gitops-a2a-server.*|chart: dm-nkp-gitops-a2a-server|g" "${FILE_PATH}"
          fi
      
      - name: Update OCIRepository
        if: steps.catalog-strategy.outputs.strategy == 'ocirepository' && steps.catalog-strategy.outputs.strategy != 'skip'
        working-directory: catalog-repo
        env:
          CHART_URL: oci://${{ env.REGISTRY }}/${{ github.repository_owner }}/charts/dm-nkp-gitops-a2a-server
          CHART_VERSION: ${{ needs.helm.outputs.chart_version }}
          FILE_PATH: ${{ steps.catalog-strategy.outputs.file_path }}
        run: |
          echo "Updating OCIRepository at ${FILE_PATH}"
          # Update ref in OCIRepository
          if command -v yq &> /dev/null; then
            yq eval ".spec.ref.tag = \"${CHART_VERSION}\"" -i "${FILE_PATH}"
            yq eval ".spec.url = \"${CHART_URL}\"" -i "${FILE_PATH}"
          else
            sed -i "s|tag:.*|tag: ${CHART_VERSION}|g" "${FILE_PATH}"
            sed -i "s|url:.*|url: ${CHART_URL}|g" "${FILE_PATH}"
          fi
      
      - name: Update catalog manifest
        if: steps.catalog-strategy.outputs.strategy == 'catalog-manifest' || steps.catalog-strategy.outputs.strategy == 'apps-manifest'
        working-directory: catalog-repo
        env:
          CHART_URL: oci://${{ env.REGISTRY }}/${{ github.repository_owner }}/charts/dm-nkp-gitops-a2a-server
          CHART_VERSION: ${{ needs.helm.outputs.chart_version }}
          FILE_PATH: ${{ steps.catalog-strategy.outputs.file_path }}
        run: |
          echo "Updating catalog manifest at ${FILE_PATH}"
          # Update version in catalog manifest (YAML format)
          if command -v yq &> /dev/null; then
            yq eval ".apps.dm-nkp-gitops-a2a-server.version = \"${CHART_VERSION}\"" -i "${FILE_PATH}" || \
            yq eval ".applications.dm-nkp-gitops-a2a-server.version = \"${CHART_VERSION}\"" -i "${FILE_PATH}" || \
            yq eval ".[] | select(.name == \"dm-nkp-gitops-a2a-server\") | .version = \"${CHART_VERSION}\"" -i "${FILE_PATH}"
          else
            # Fallback to sed
            sed -i "s|dm-nkp-gitops-a2a-server.*version.*|dm-nkp-gitops-a2a-server: version: ${CHART_VERSION}|g" "${FILE_PATH}"
          fi
      
      - name: Create HelmRelease if missing
        if: steps.catalog-strategy.outputs.strategy == 'auto-create' && steps.catalog-strategy.outputs.strategy != 'skip'
        working-directory: catalog-repo
        env:
          CHART_URL: oci://${{ env.REGISTRY }}/${{ github.repository_owner }}/charts/dm-nkp-gitops-a2a-server
          CHART_VERSION: ${{ needs.helm.outputs.chart_version }}
          APP_NAME: dm-nkp-gitops-a2a-server
        run: |
          echo "Creating HelmRelease for ${APP_NAME}"
          mkdir -p "apps/${APP_NAME}"
          cat > "apps/${APP_NAME}/helmrelease.yaml" <<EOF
          apiVersion: helm.toolkit.fluxcd.io/v2beta1
          kind: HelmRelease
          metadata:
            name: ${APP_NAME}
            namespace: gitops-agent
          spec:
            interval: 5m
            chart:
              spec:
                chart: dm-nkp-gitops-a2a-server
                version: ${CHART_VERSION}
                sourceRef:
                  kind: OCIRepository
                  name: ${APP_NAME}-chart
                interval: 1m
          ---
          apiVersion: source.toolkit.fluxcd.io/v1beta2
          kind: OCIRepository
          metadata:
            name: ${APP_NAME}-chart
            namespace: gitops-agent
          spec:
            interval: 5m
            url: ${CHART_URL}
            ref:
              tag: ${CHART_VERSION}
          EOF
      
      - name: Check for changes
        id: check-changes
        if: steps.catalog-strategy.outputs.strategy != 'skip'
        working-directory: catalog-repo
        run: |
          if [ -n "$(git status --porcelain)" ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
            git diff
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "No changes detected in catalog"
          fi
      
      - name: Commit and push catalog update (Direct Push)
        if: steps.check-changes.outputs.has_changes == 'true' && env.CATALOG_UPDATE_METHOD == 'push'
        working-directory: catalog-repo
        env:
          VERSION: ${{ needs.helm.outputs.chart_version }}
          IS_RELEASE: ${{ needs.helm.outputs.is_release }}
          TOKEN: ${{ steps.auth.outputs.token }}
        run: |
          git add -A
          if [ "${IS_RELEASE}" = "true" ]; then
            COMMIT_MSG="chore: update dm-nkp-gitops-a2a-server to v${VERSION} [skip ci]"
          else
            COMMIT_MSG="chore: update dm-nkp-gitops-a2a-server to ${VERSION} [skip ci]"
          fi
          git commit -m "${COMMIT_MSG}"
          # Configure git to use token for push
          git remote set-url origin https://x-access-token:${TOKEN}@github.com/${{ env.CATALOG_OWNER }}/${{ env.CATALOG_REPO }}.git
          git push origin HEAD:master || git push origin HEAD:main
      
      - name: Create Pull Request (Recommended)
        if: steps.check-changes.outputs.has_changes == 'true' && env.CATALOG_UPDATE_METHOD == 'pr'
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.CATALOG_REPO_TOKEN || secrets.GITHUB_TOKEN }}
          path: catalog-repo
          commit-message: |
            chore: update dm-nkp-gitops-a2a-server to ${{ needs.helm.outputs.chart_version }} [skip ci]
            
            Automated catalog update from CD workflow.
          title: "chore: update dm-nkp-gitops-a2a-server to ${{ needs.helm.outputs.chart_version }}"
          body: |
            ## Automated Catalog Update
            
            This PR updates the catalog with the new version of `dm-nkp-gitops-a2a-server`.
            
            **Details:**
            - **Chart Version**: `${{ needs.helm.outputs.chart_version }}`
            - **Chart URL**: `oci://${{ env.REGISTRY }}/${{ github.repository_owner }}/charts/dm-nkp-gitops-a2a-server`
            - **Update Strategy**: `${{ steps.catalog-strategy.outputs.strategy }}`
            - **File Updated**: `${{ steps.catalog-strategy.outputs.file_path }}`
            - **Source**: [Workflow Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            
            **Triggered by:**
            - Repository: `${{ github.repository }}`
            - Commit: `${{ github.sha }}`
            - Ref: `${{ github.ref }}`
            
            ---
            
            This is an automated update. Review the changes before merging.
          branch: update/dm-nkp-gitops-a2a-server-${{ needs.helm.outputs.chart_version }}
          delete-branch: true
          labels: |
            automated
            catalog-update
          draft: false
      
      - name: Summary
        if: always()
        run: |
          echo "## Catalog Update Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check if catalog repo was accessible
          if [ "${{ steps.catalog-strategy.outputs.strategy }}" = "skip" ]; then
            echo "### âš ï¸ Catalog Update Skipped" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Catalog repository could not be accessed." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Possible causes:**" >> $GITHUB_STEP_SUMMARY
            echo "1. Catalog repo doesn't exist: \`${{ env.CATALOG_OWNER }}/${{ env.CATALOG_REPO }}\`" >> $GITHUB_STEP_SUMMARY
            echo "2. Cross-org access needed - Add \`CATALOG_REPO_TOKEN\` secret" >> $GITHUB_STEP_SUMMARY
            echo "3. Repository is private and token lacks access" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Solution:**" >> $GITHUB_STEP_SUMMARY
            echo "- If cross-org: Add \`CATALOG_REPO_TOKEN\` secret (PAT with 'repo' scope)" >> $GITHUB_STEP_SUMMARY
            echo "- If same-org: Check repository name and permissions" >> $GITHUB_STEP_SUMMARY
            echo "- See: [Catalog Update Secrets Guide](docs/CATALOG_UPDATE_SECRETS.md)" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Update Method**: ${{ env.CATALOG_UPDATE_METHOD }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Strategy**: ${{ steps.catalog-strategy.outputs.strategy }}" >> $GITHUB_STEP_SUMMARY
            echo "- **File Updated**: ${{ steps.catalog-strategy.outputs.file_path }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Chart Version**: ${{ needs.helm.outputs.chart_version }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Chart URL**: oci://${{ env.REGISTRY }}/${{ github.repository_owner }}/charts/dm-nkp-gitops-a2a-server" >> $GITHUB_STEP_SUMMARY
            if [ "${{ steps.check-changes.outputs.has_changes }}" = "true" ]; then
              if [ "${{ env.CATALOG_UPDATE_METHOD }}" = "pr" ]; then
                echo "- **Status**: âœ… Pull request created successfully" >> $GITHUB_STEP_SUMMARY
              else
                echo "- **Status**: âœ… Catalog updated successfully (direct push)" >> $GITHUB_STEP_SUMMARY
              fi
            else
              echo "- **Status**: â„¹ï¸ No changes needed" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Authentication" >> $GITHUB_STEP_SUMMARY
            echo "- **Method**: ${{ steps.auth.outputs.auth_method }}" >> $GITHUB_STEP_SUMMARY
            if [ "${{ steps.auth.outputs.auth_method }}" = "pat" ]; then
              echo "- âœ… Using PAT (cross-org support enabled)" >> $GITHUB_STEP_SUMMARY
            else
              echo "- â„¹ï¸ Using GITHUB_TOKEN (same-org only)" >> $GITHUB_STEP_SUMMARY
              if [ "${{ env.CATALOG_OWNER }}" != "${{ github.repository_owner }}" ]; then
                echo "- âš ï¸ **Cross-org detected**: Add \`CATALOG_REPO_TOKEN\` secret for access" >> $GITHUB_STEP_SUMMARY
                echo "  - See: [Setup Guide](docs/CATALOG_UPDATE_SECRETS.md)" >> $GITHUB_STEP_SUMMARY
              fi
            fi
          fi
